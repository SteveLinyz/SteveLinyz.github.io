---
title: Java枚举类
date: 2021.6.27
cover: https://images.pexels.com/photos/6100565/pexels-photo-6100565.jpeg?auto=compress&cs=tinysrgb&h=750&w=1260

---


## 1. 简介

`enum` 的全称为 enumeration， 是 JDK5 中引入的特性。

在 Java 中，被 `enum` 关键字修饰的类型就是枚举类型。形式如下：

```java
enum ColorEn { RED, GREEN, BLUE }
```

- 当需要定义一组常量时，建议使用枚举类。
- 如果枚举类中只有一个对象，则可以作为单例模式实现方式。

**枚举的好处**：可以将常量组织起来，统一进行管理。

**枚举的典型应用场景**：错误码、状态机等。

## 2. 枚举的本质

`java.lang.Enum`类声明

```java
public abstract class Enum<E extends Enum<E>>
        implements Comparable<E>, Serializable { ... }
```

> 说明：
>
> **枚举的本质是 `java.lang.Enum` 的子类。**
>
> 尽管 `enum` 看起来像是一种新的数据类型，事实上，**enum 是一种受限制的类，并且具有自己的方法**。枚举这种特殊的类因为被修饰为 `final`，所以不能继承其他类。
>
> 定义的枚举值，会被默认修饰为 `public static final` ，从修饰关键字，即可看出枚举值本质上是静态常量。

## 3. 枚举的方法

在 enum 中，提供了一些基本方法：

- `values()`：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序。
- `valuesOf(String name)`：返回枚举类中对象名是name的对象。
- `name()`：返回实例名。
- `ordinal()`：返回实例声明时的次序，从 0 开始。
- `getDeclaringClass()`：返回实例所属的 enum 类型。
- `equals()` ：判断是否为同一个对象。

可以使用 `==` 来比较`enum`实例。

此外，`java.lang.Enum`实现了`Comparable`和 `Serializable` 接口，所以也提供 `compareTo()` 方法。

**例：展示 enum 的基本方法**

[TexasHoldem.java](D:\IDEAPrograms\project1\src\com\pro\enu\TexasHoldem.java)

## 4. 枚举的特性

枚举的特性，归结起来就是一句话：

> **除了不能继承，基本上可以将 `enum` 看做一个常规的类**。

但是这句话需要拆分去理解，让我们细细道来。

### 4.1. 基本特性

**如果枚举中没有定义方法，也可以在最后一个实例后面加逗号、分号或什么都不加。**

如果枚举中没有定义方法，**枚举值默认为从 0 开始的有序数值**。以 Color 枚举类型举例，它的枚举常量依次为 `RED：0，GREEN：1，BLUE：2`。

### 4.2. 枚举可以添加方法

如何为枚举显式的赋值。

#### 4.2.1 枚举可以添加普通方法、静态方法、抽象方法、构造方法

Java 虽然不能直接为实例赋值，但是它有更优秀的解决方案：**为 enum 添加方法来间接实现显式赋值**。

创建 `enum` 时，可以为其添加多种方法，甚至可以为其添加构造方法。

**注意：如果要为 enum 定义方法，那么必须在 enum 的最后一个实例尾部添加一个分号。此外，在 enum 中，必须先定义实例，不能将字段或方法定义在实例前面。否则，编译器会报错。**

**例：全面展示如何在枚举中定义普通方法、静态方法、抽象方法、构造方法**

```java
public enum ErrorCodeEn {
    OK(0) {
        @Override
        public String getDescription() {
            return "成功";
        }
    },
    ERROR_A(100) {
        @Override
        public String getDescription() {
            return "错误A";
        }
    },
    ERROR_B(200) {
        @Override
        public String getDescription() {
            return "错误B";
        }
    };

    private int code;

    // 构造方法：enum的构造方法只能被声明为private权限或不声明权限
    private ErrorCodeEn(int number) { // 构造方法
        this.code = number;
    }

    public int getCode() { // 普通方法
        return code;
    } // 普通方法

    public abstract String getDescription(); // 抽象方法

    public static void main(String args[]) { // 静态方法
        for (ErrorCodeEn s : ErrorCodeEn.values()) {
            System.out.println("code: " + s.getCode() + ", description: " + s.getDescription());
        }
    }
}
// Output:
// code: 0, description: 成功
// code: 100, description: 错误A
// code: 200, description: 错误B
```

### 4.3 枚举实现接口

枚举可以实现接口，但是不能继承。

因为 `enum` 实际上都继承自 `java.lang.Enum` 类，而 Java 不支持多重继承，所以 `enum` 不能再继承其他类，当然也不能继承另一个 `enum`。

