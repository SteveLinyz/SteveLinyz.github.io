# 1. 概览

容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。

## 1.1 **Collection**

![image-20210706192140377](https://gitee.com/steve-lin08/image-host/raw/master/20210706192147.png)

### 1. Set

- TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
- HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
- LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。

### 2. List

- ArrayList：基于动态数组实现，支持随机访问。
- Vector：和 ArrayList 类似，但它是线程安全的。
- LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。

### 3. Queue

- LinkedList：可以用它来实现双向队列。
- PriorityQueue：基于堆结构实现，可以用它来实现优先队列。

## 1.2 Map

![Map](https://gitee.com/steve-lin08/image-host/raw/master/20210706192429.png)

- TreeMap：基于红黑树实现。
- HashMap：基于哈希表实现。
- HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
- LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。

# 2. Collection

## 2.1 Collection常用方法

```java
boolean add(Object o)//添加对象到集合
boolean remove(Object o)//删除指定的对象
int size()//返回当前集合中元素的数量
boolean contains(Object o)//查找集合中是否有指定的对象
boolean isEmpty()//判断集合是否为空
Iterator iterator()//返回一个迭代器
boolean containsAll(Collection c)//查找集合中是否有集合c中的元素
boolean addAll(Collection c)//将集合c中所有的元素添加给该集合
void clear()//删除集合中所有元素
void removeAll(Collection c)//从集合中删除c集合中也有的元素
void retainAll(Collection c)//从集合中删除集合c中不包含的元素
```

## 2.2 ArrayList

**ArrayList可以顺序存放重复的元素，速度快，但是线程不安全。**

因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

数组的默认大小为 10。

```java
private static final int DEFAULT_CAPACITY = 10;
```

### 2.2.1 扩容

添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 `oldCapacity + (oldCapacity >> 1)`，即 oldCapacity+oldCapacity/2。其中 oldCapacity >> 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）

扩容操作需要调用 `Arrays.copyOf()` 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。

### 2.2.2 删除元素

需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。

```java
public E remove(int index) {
    rangeCheck(index);
    modCount++;
    E oldValue = elementData(index);
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // clear to let GC do its work
    return oldValue;
}
```

## 2.3 LinkedList

基于双向链表实现，使用 Node 存储链表节点信息。

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
}
```

每个链表存储了 first 和 last 指针：

```java
transient Node<E> first;
transient Node<E> last;
```

![image-20210706193430344](https://gitee.com/steve-lin08/image-host/raw/master/20210706193430.png)

### 2.3.1 与ArrayList的比较

ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：

- 数组支持随机访问，但插入删除的代价很高，需要移动大量元素；
- 链表不支持随机访问，但插入删除只需要改变指针。

## 2.4 Vector

### 2.4.1 同步

它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。

```java
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

public synchronized E get(int index) {
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
```

### 2.4.2 扩容

Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。

### 2.4.3 与 ArrayList 的比较

- Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；
- Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。

## 2.5 HashSet

Set集的元素可以**无序**但是**不可以重复**

- HashSet是Set的一个重要实现类，称为哈希集
- HashSet中是允许存在一个null元素的
- 具有良好的存取和查找性能

HashSet按Hash算法来存储集合中的元素，因此具有很好的存取和查找性能。底层数据结构是**哈希表**。

### 2.5.1 内部存储机制

当向HashSet集合中存入一个元素时:

1. HashSet会调用该对象的**hashCode()**方法来得到该对象的hashCode值。

2. 根据该hashCode值决定该对象在HashSet中的存储位置(下标)。

3. 如果该位置已经存放了元素，则用**equals()**来判断两个元素是否相等。

   如果相等，则覆盖。

   如果不等，则用指针将两元素链接在一起。

HashCode表用每个元素的hashCode值来计算其存储位置，从而可以自由增加HashCode的长度，并根据元素的hashCode值来访问元素。而不用一个个遍历索引去访问，**这就是它比数组快的原因**。

### 2.5.2 重写hashCode()和equals()

对于一个类，如果没有重写过hashCode()和equals()，则无法判断其对象的属性是否一致。

```java
 @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return Objects.equals(name, user.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
```

## 2.6 LinkedHashSet

HashSet还有一个子类LinkedList、LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的，也就是说当遍历集合LinkedHashSet集合里的元素时，**集合将会按元素的添加顺序来访问集合里的元素**。
输出集合里的元素时，元素顺序总是与添加顺序一致。**但是LinkedHashSet依然是HashSet，因此它不允许集合重复。**

## 2.7 TreeSet

TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。

### 2.7.1 内部存储机制

TreeSet内部实现的是**红黑树**，默认整形排序为从小到大。

TreeSet中的元素支持2种排序方式：**自然排序** 或者 **根据创建TreeSet 时提供的 Comparator 进行排序**。这取决于使用的构造方法。

